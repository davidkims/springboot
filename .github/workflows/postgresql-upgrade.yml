name: Automatic MySQL Backup # 워크플로우의 이름

on:
  push:
    branches:
      - main # main 브랜치에 푸시될 때 트리거 (예: 코드 변경 시)
    paths:
      # 백업 로직에 영향을 줄 수 있는 파일 변경 시 트리거
      - '**.sql'
      - '.github/workflows/auto-backup.yml' # 이 워크플로우 파일 자체 변경 시
      # 여기에 백업 대상이 되는 애플리케이션 코드 경로 등을 추가할 수 있습니다.

  schedule:
    # UTC 기준 매일 자정(KST로 오전 9시)에 주기적으로 실행
    - cron: '0 0 * * *'

  workflow_dispatch: # GitHub UI에서 수동으로 워크플로우 실행 허용
    inputs:
      reason:
        description: 'Reason for manual trigger (e.g., "urgent backup")'
        required: false
        default: 'Manual trigger from UI'

jobs:
  mysql-backup:
    runs-on: ubuntu-latest # Job을 실행할 러너 환경

    permissions:
      contents: write # 리포지토리 내용을 읽고, 백업 파일을 푸시하기 위해 'write' 권한 필요

    steps:
      - name: Checkout repository # 리포지토리 코드를 러너에 체크아웃
        uses: actions/checkout@v4
        with:
          # `GITHUB_TOKEN`은 푸시 권한을 가짐. `permissions: contents: write`와 함께 작동.
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up MySQL Client (if not already present) # MySQL 클라이언트 설치 (mysqldump 사용을 위함)
        run: |
          sudo apt-get update
          sudo apt-get install -y mysql-client-core-8.0 # Ubuntu 20.04/22.04 기준, 버전 확인 필요

      - name: Create Backup Directory # 백업 파일을 저장할 디렉토리 생성
        run: mkdir -p ./backups

      - name: Run MySQL Backup Script # MySQL 백업 스크립트 실행
        id: perform_backup # 이 스텝에 ID 부여 (다음 스텝에서 내용이 변경되었는지 확인하기 위함)
        run: |
          #!/bin/bash
          # 현재 날짜 및 시간으로 파일명 생성
          BACKUP_FILENAME="mysql_backup_$(date +%Y%m%d_%H%M%S).sql"
          BACKUP_FILE_PATH="./backups/$BACKUP_FILENAME"

          echo "--- MySQL 백업 스크립트 시작 ---"
          echo "백업 파일명: $BACKUP_FILENAME"
          echo "백업 파일 경로: $BACKUP_FILE_PATH"
          echo "MySQL 호스트: $MYSQL_HOST"
          echo "MySQL 포트: $MYSQL_PORT"
          echo "MySQL 사용자: $MYSQL_USER"

          # MYSQL_PASSWORD 환경 변수가 설정되었는지 확인 (GitHub Secrets에서 주입될 값)
          if [ -z "$MYSQL_PASSWORD" ]; then
              echo "⭐⭐⭐ 치명적 오류: MySQL 비밀번호(MYSQL_PASSWORD)가 환경 변수로 설정되지 않았습니다. ⭐⭐⭐"
              echo "--------------------------------------------------------------------------------"
              echo "이 오류는 CI/CD 환경의 GitHub Secrets에 'MYSQL_ROOT_PASSWORD'가 없거나"
              echo "워크플로우 YAML에서 이를 'MYSQL_PASSWORD' 환경 변수로 제대로 전달하지 않았기 때문에 발생합니다."
              echo ""
              echo "아래 단계를 따라 GitHub Secrets 설정을 다시 확인하십시오:"
              echo "1. GitHub 저장소로 이동 -> 'Settings' 탭 -> 'Secrets and variables' 아래의 'Actions' 클릭."
              echo "2. 'Repository secrets' 탭에서 'MYSQL_ROOT_PASSWORD'라는 이름의 비밀이 있는지 확인."
              echo "   - 없으면 'New repository secret'으로 생성 (이름: MYSQL_ROOT_PASSWORD, 값: 실제 비밀번호)."
              echo "   - 있으면 값이 올바른지 확인."
              echo "--------------------------------------------------------------------------------"
              exit 1 # 스크립트 종료 및 워크플로우 실패
          fi

          # 모든 데이터베이스를 백업하거나, 특정 데이터베이스만 백업
          if [ -n "$MYSQL_DATABASE" ]; then
              echo "특정 데이터베이스 '$MYSQL_DATABASE'를 백업합니다."
              mysqldump -h"$MYSQL_HOST" -P"$MYSQL_PORT" -u"$MYSQL_USER" -p"$MYSQL_PASSWORD" "$MYSQL_DATABASE" > "$BACKUP_FILE_PATH"
          else
              echo "모든 데이터베이스를 백업합니다."
              mysqldump --all-databases -h"$MYSQL_HOST" -P"$MYSQL_PORT" -u"$MYSQL_USER" -p"$MYSQL_PASSWORD" > "$BACKUP_FILE_PATH"
          fi

          if [ $? -eq 0 ]; then
              echo "--- MySQL 백업 성공 ---"
              echo "백업 파일이 '$BACKUP_FILE_PATH'에 생성되었습니다."
              # 백업 파일이 성공적으로 생성되었음을 다음 스텝에 전달
              echo "::set-output name=backup_successful::true"
              echo "::set-output name=backup_file_path::$BACKUP_FILE_PATH"
          else
              echo "--- MySQL 백업 실패 ---"
              echo "백업 중 오류가 발생했습니다. 로그를 확인하십시오."
              echo "::set-output name=backup_successful::false"
              exit 1 # 스크립트 실패
          fi
        env: # 백업 스크립트에 필요한 환경 변수 설정
          MYSQL_HOST: localhost # MySQL 호스트 (Docker 컨테이너나 다른 서버인 경우 변경 필요)
          MYSQL_PORT: 3306 # MySQL 포트
          MYSQL_USER: root # MySQL 사용자
          # 중요: GitHub Secrets에서 비밀번호를 가져와 환경 변수로 주입
          MYSQL_PASSWORD: ${{ secrets.MYSQL_ROOT_PASSWORD }}
          # MYSQL_DATABASE: your_database_name # 특정 데이터베이스만 백업하려면 주석 해제 후 이름 지정

      - name: Configure Git for automated commit # Git 사용자 정보 설정
        if: steps.perform_backup.outputs.backup_successful == 'true' # 백업이 성공했을 때만 실행
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Check for new backup file # 새로 생성된 백업 파일이 있는지 확인
        id: git_status
        if: steps.perform_backup.outputs.backup_successful == 'true'
        run: |
          git add ./backups/ # backups 디렉토리 전체를 스테이징
          # 스테이징된 변경 사항이 없으면 'has_changes'를 'false'로 설정
          if git diff --staged --quiet; then
            echo "::set-output name=has_changes::false"
            echo "No new backup file or changes to commit."
          else
            echo "::set-output name=has_changes::true"
            echo "New backup file detected. Proceeding to commit."
          fi

      - name: Commit and Push backup file # 변경 사항이 있을 경우에만 커밋 및 푸시 진행
        if: steps.git_status.outputs.has_changes == 'true'
        run: |
          echo "Attempting to commit and push backup file..."

          # --- Git 동기화 로직: CRITICAL FIX for 'fetch first' errors ---
          # 1. 원격 'main' 브랜치의 최신 변경 사항 가져오기 (로컬에는 적용 안 함)
          echo "Fetching latest changes from remote/main..."
          git fetch origin main

          # 2. 로컬 변경 사항을 원격 'main'의 최신 상태 위에 리베이스 (재적용) 시도
          #    --autostash: 임시 변경사항을 스태시했다가 리베이스 후 다시 적용
          #    --no-edit: 인터랙티브 리베이스 에디터 열지 않음
          #    || { ... }: rebase 실패 시 대체 명령 실행
          echo "Attempting to rebase local changes onto remote/main..."
          git rebase origin/main --autostash --no-edit || {
            echo "Rebase failed. Trying to merge remote changes instead."
            # 3. 리베이스 실패 시, 원격 'main' 브랜치와 병합 시도
            #    --no-edit: 병합 커밋 메시지 에디터 열지 않음
            git merge origin/main --no-edit || {
              echo "Error: Both rebase and merge failed due to unresolvable conflicts. Manual intervention is required."
              exit 1 # 병합도 실패하면 워크플로우를 실패시킴
            }
          }

          # 4. 변경 사항 커밋
          #    'git commit'이 실패할 경우 (예: rebase 과정에서 이미 커밋되거나 변경 사항이 없는 경우),
          #    오류를 무시하고 진행 (`|| true` 사용)
          echo "Committing backup file..."
          git commit -m "feat(backup): Auto-generated MySQL backup for ${{ github.ref_name }}" || true

          # 5. 최종적으로 변경 사항을 원격 리포지토리로 푸시
          echo "Pushing backup file to origin/main..."
          git push origin main
          echo "Successfully pushed MySQL backup."

      # --- 선택 사항: 백업 파일 아티팩트로 저장 ---
      - name: Upload backup file as artifact # 백업 파일을 GitHub Actions 아티팩트로 업로드 (다운로드 가능)
        if: steps.perform_backup.outputs.backup_successful == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: mysql-backup-${{ github.run_id }}
          path: ${{ steps.perform_backup.outputs.backup_file_path }}
          retention-days: 7 # 아티팩트 보존 기간 (일)
